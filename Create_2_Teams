let teamSizesDiff = 2;
let scoresDiff = 71;
let BinalDiff = 4;
let teams, throwersScore, runnersScore, scores, teamSizes;
let players;
let j = 0; // Counter variable to track the number of iterations
let BinalScore; // Declare BinalScore array

while (teamSizesDiff > 1 || scoresDiff > 1.5 || BinalDiff > 1) {
  j++; // Increment the counter variable

  players = playerTable.data.filter(player => player.Present);

  console.log('picking players from table!');
  console.log('sorting players!');

  players.sort((a, b) => (b.Thrower + b.Runner) - (a.Thrower + a.Runner));

  teams = [[], [], [], []];
  throwersScore = [0, 0, 0, 0];
  runnersScore = [0, 0, 0, 0];
  scores = [0, 0, 0, 0];
  teamSizes = [0, 0, 0, 0];
  BinalScore = [0, 0, 0, 0]; // Initialize BinalScore array

  for (let i = 0; i < players.length; i++) {
    const currentPlayer = players[i];
    const lowestScoreTeamIndex = scores.indexOf(Math.min(...scores));
    teams[lowestScoreTeamIndex].push(currentPlayer);
    scores[lowestScoreTeamIndex] += currentPlayer.Score;
    throwersScore[lowestScoreTeamIndex] += currentPlayer.Thrower;
    runnersScore[lowestScoreTeamIndex] += currentPlayer.Runner;
    teamSizes[lowestScoreTeamIndex]++;
    BinalScore[lowestScoreTeamIndex] += currentPlayer.Binal; // Add currentPlayer's Binal to the corresponding team's BinalScore
  }

  scoresDiff = Math.abs(Math.min(...scores) - Math.max(...scores));
  runnersDiff = Math.abs(Math.min(...runnersScore) - Math.max(...runnersScore));
  teamSizesDiff = Math.abs(Math.min(...teamSizes) - Math.max(...teamSizes));
  BinalDiff = Math.abs(Math.min(...BinalScore) - Math.max(...BinalScore)); // Calculate the BinalDiff based on the teams' BinalScores
}

const allPlayers = players.map((player, index) => [player.Name, player.Score, teams.findIndex(team => team.includes(player)) + 1]);

const playerNames = allPlayers.map(player => player[0]);
const playerScores = allPlayers.map(player => player[1]);
const playerTeamNumbers = allPlayers.map(player => player[2]);
const ID = Array.from({ length: allPlayers.length }, (_, index) => index + 1);

return {
  team1: teams[0],
  team2: teams[1],
  team3: teams[2],
  team4: teams[3],
  scores: scores,
  throwersScore: throwersScore,
  runnersScore: runnersScore,
  scoresDiff: scoresDiff,
  runnersDiff: runnersDiff,
  teamSizesDiff: teamSizesDiff,
  BinalScore: BinalScore,
  BinalDiff: BinalDiff,
  playerNames: playerNames,
  playerScores: playerScores,
  playerTeamNumbers: playerTeamNumbers,
  ID: ID,
  j: j
};

``
















const players = playerTable.data.filter(player => player.Present);

console.log('picking players from table!');
console.log('sorting players!');

// shuffle the list of players
function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}
shuffle(players);

// sort players by overall score in descending order
players.sort((a, b) => b.Runner - a.Runner);

// initialize list for teams
const teams = [[], []];

// initialize variables to track number of players who can throw and run and aggregate scores
let throwersScore = [0, 0];
let runnersScore = [0, 0];
let scores = [0, 0];

// add players to teams, prioritizing score and balance
for (let i = 0; i < players.length; i++) { 
  const currentPlayer = players[i];

  // check which team has less throwers and runners
  const throwersDiff = Math.abs(throwersScore[0] - throwersScore[1]);
  const runnersDiff = Math.abs(runnersScore[0] - runnersScore[1]);

  // if both teams have equal throwers and runners, add to team with lower overall score
  if (throwersDiff === 0 && runnersDiff === 0) {
    if (scores[0] <= scores[1]) {
      teams[0].push(currentPlayer);
      scores[0] += currentPlayer.Score;
      throwersScore[0] += currentPlayer.Thrower;
      runnersScore[0] += currentPlayer.Runner;
    }
    else {
      teams[1].push(currentPlayer);
      scores[1] += currentPlayer.Score;
      throwersScore[1] += currentPlayer.Thrower;
      runnersScore[1] += currentPlayer.Runner;
    }
  }
  else {
    // add to team with lower count of specific skill
    if (throwersDiff > runnersDiff) {
      if (throwersScore[0] <= throwersScore[1]) {
        teams[0].push(currentPlayer);
        scores[0] += currentPlayer.Score;
        throwersScore[0] += currentPlayer.Thrower;
        runnersScore[0] += currentPlayer.Runner;
      }
      else {
        teams[1].push(currentPlayer);
        scores[1] += currentPlayer.Score;
        throwersScore[1] += currentPlayer.Thrower;
        runnersScore[1] += currentPlayer.Runner;
      }
    }
    else {
      if (runnersScore[0] <= runnersScore[1]) {
        teams[0].push(currentPlayer);
        scores[0] += currentPlayer.Score;
        throwersScore[0] += currentPlayer.Thrower;
        runnersScore[0] += currentPlayer.Runner;
      }
      else {
        teams[1].push(currentPlayer);
        scores[1] += currentPlayer.Score;
        throwersScore[1] += currentPlayer.Thrower;
        runnersScore[1] += currentPlayer.Runner;
      }
    }
  }
}



return { team1: teams[0], team2: teams[1], scores: scores,  throwersScore:  throwersScore, runnersScore:  runnersScore };
